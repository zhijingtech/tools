package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/constant"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v3"
)

var flagconf = flag.String("c", "./conf.yml", "config path, eg: -c ./conf.yml")

func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of enum2func:\n")
	fmt.Fprintf(os.Stderr, "\tenum2func -c ./conf.yml\n")
	flag.PrintDefaults()
}

type Conf struct {
	Tasks []*Task `yaml:"tasks"`
}
type Task struct {
	Type        string   `yaml:"type"`
	Input       string   `yaml:"input"`
	TrimPrefix  string   `yaml:"trimPrefix"`
	LineComment bool     `yaml:"lineComment"`
	BuildTags   []string `yaml:"buildTags"`
	Package     string   `yaml:"package"`
	Imports     []string `yaml:"imports"`
	Lines       []string `yaml:"lines"`
	Output      string   `yaml:"output"`
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("enum2func: ")
	flag.Usage = Usage
	flag.Parse()

	confData, err := os.ReadFile(*flagconf)
	if err != nil {
		log.Fatalf("[%s] failed to read conf file: %s", *flagconf, err)
	}
	var conf Conf
	err = yaml.Unmarshal(confData, &conf)
	if err != nil {
		log.Fatalf("[%s] failed to unmarshal conf: %s", *flagconf, err)
	}

	for _, task := range conf.Tasks {
		fmt.Println("---ENUM2FUNC---")
		do(task)
	}
	fmt.Println("---ENUM2FUNC---")
}

func do(task *Task) {
	fmt.Println(task.Type, task.Input)
	if task.Type == "" {
		log.Fatal("type is empty")
	}
	if task.Input == "" {
		log.Fatal("path is empty")
	}
	if len(task.Lines) == 0 {
		log.Fatal("lines is empty")
	}
	if task.Output == "" {
		dir := task.Input
		if !isDirectory(dir) {
			dir = filepath.Dir(dir)
		}
		filename := fmt.Sprintf("%s_func_gen.go", task.Type)
		task.Output = filepath.Join(dir, strings.ToLower(filename))
	}

	// Parse the package once.
	g := Generator{
		trimPrefix: task.TrimPrefix,
	}

	g.parsePackage([]string{task.Input}, task.BuildTags)
	if task.Package == "" {
		task.Package = g.pkg.name
	}

	// Print the header and package clause.
	g.Printf(`// Code generated by "enum2func"; !!!DO NOT EDIT!!!`)
	g.Printf("\npackage %s\n", task.Package)
	if len(task.Imports) > 0 {
		g.Printf("import (\n")
		for _, item := range task.Imports {
			g.Printf("    %s\n", item)
		}
		g.Printf(")\n")
	}

	g.generate(task.Type, task.Lines)

	// Format the output.
	src := g.format()

	// Write to file.
	err := os.WriteFile(task.Output, src, 0o644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// isDirectory reports whether the named file is a directory.
func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	pkg *Package     // Package we are scanning.

	trimPrefix  string
	lineComment bool

	logf func(format string, args ...any) // test logging hook; nil when not testing
}

func (g *Generator) Printf(format string, args ...any) {
	fmt.Fprintf(&g.buf, format, args...)
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
	// These fields are reset for each type being generated.
	typeName string  // Name of the constant type.
	values   []Value // Accumulator for constant values of that type.

	trimPrefix  string
	lineComment bool
}

type Package struct {
	name  string
	defs  map[*ast.Ident]types.Object
	files []*File
}

// parsePackage analyzes the single package constructed from the patterns and tags.
// parsePackage exits if there is an error.
func (g *Generator) parsePackage(patterns []string, tags []string) {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
		Logf:       g.logf,
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages matching %v", len(pkgs), strings.Join(patterns, " "))
	}
	g.addPackage(pkgs[0])
}

// addPackage adds a type checked Package and its syntax files to the generator.
func (g *Generator) addPackage(pkg *packages.Package) {
	g.pkg = &Package{
		name:  pkg.Name,
		defs:  pkg.TypesInfo.Defs,
		files: make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.pkg.files[i] = &File{
			file:        file,
			pkg:         g.pkg,
			trimPrefix:  g.trimPrefix,
			lineComment: g.lineComment,
		}
	}
}

// generate produces the String method for the named type.
func (g *Generator) generate(typeName string, lines []string) {
	values := make([]Value, 0, 100)
	for _, file := range g.pkg.files {
		// Set the state for this run of the walker.
		file.typeName = typeName
		file.values = nil
		if file.file != nil {
			ast.Inspect(file.file, file.genDecl)
			values = append(values, file.values...)
		}
	}

	if len(values) == 0 {
		log.Fatalf("no values defined for type %s", typeName)
	}

	var tpls []*template.Template
	for _, line := range lines {
		tpl, err := template.New(line).Parse(line)
		if err != nil {
			log.Fatalf("[%s] failed to parse template: %s'", line, err)
		}
		tpls = append(tpls, tpl)
	}
	for _, v := range values {
		for _, tpl := range tpls {
			err := tpl.Execute(&g.buf, v)
			if err != nil {
				log.Fatalf("[%s] failed to execution template: %s", tpl.Name(), err)
			}
			g.buf.WriteString("\n")
		}
	}
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// Value represents a declared constant.
type Value struct {
	Name        string // The name of the constant.
	TrimmedName string // The name with trimmed prefix.
	// The Value is stored as a bit pattern alone. The boolean tells us
	// whether to interpret it as an int64 or a uint64; the only place
	// this matters is when sorting.
	// Much of the time the str field is all we need; it is printed
	// by Value.String.
	Value  uint64 // Will be converted to int64 when needed.
	Signed bool   // Whether the constant is a signed type.
	Str    string // The string representation given by the "go/constant" package.

	Comment              string
	CommentSpecifiedType string
}

func (v *Value) String() string {
	return v.Str
}

// genDecl processes one declaration clause.
func (f *File) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.CONST {
		// We only care about const declarations.
		return true
	}
	// The name of the type of the constants we are declaring.
	// Can change if this is a multi-element declaration.
	typ := ""
	// Loop over the elements of the declaration. Each element is a ValueSpec:
	// a list of names possibly followed by a type, possibly followed by values.
	// If the type and value are both missing, we carry down the type (and value,
	// but the "go/types" package takes care of that).
	for _, spec := range decl.Specs {
		vspec := spec.(*ast.ValueSpec) // Guaranteed to succeed as this is CONST.
		if vspec.Type == nil && len(vspec.Values) > 0 {
			// "X = 1". With no type but a value. If the constant is untyped,
			// skip this vspec and reset the remembered type.
			typ = ""

			// If this is a simple type conversion, remember the type.
			// We don't mind if this is actually a call; a qualified call won't
			// be matched (that will be SelectorExpr, not Ident), and only unusual
			// situations will result in a function call that appears to be
			// a type conversion.
			ce, ok := vspec.Values[0].(*ast.CallExpr)
			if !ok {
				continue
			}
			id, ok := ce.Fun.(*ast.Ident)
			if !ok {
				continue
			}
			typ = id.Name
		}
		if vspec.Type != nil {
			// "X T". We have a type. Remember it.
			ident, ok := vspec.Type.(*ast.Ident)
			if !ok {
				continue
			}
			typ = ident.Name
		}
		if typ != f.typeName {
			// This is not the type we're looking for.
			continue
		}
		// We now have a list of names (from one line of source code) all being
		// declared with the desired type.
		// Grab their names and actual values and store them in f.values.
		for _, name := range vspec.Names {
			if name.Name == "_" {
				continue
			}
			// This dance lets the type checker find the values for us. It's a
			// bit tricky: look up the object declared by the name, find its
			// types.Const, and extract its value.
			obj, ok := f.pkg.defs[name]
			if !ok {
				log.Fatalf("no value for constant %s", name)
			}
			info := obj.Type().Underlying().(*types.Basic).Info()
			// if info&types.IsInteger == 0 {
			// 	log.Fatalf("can't handle non-integer constant type %s", typ)
			// }
			value := obj.(*types.Const).Val() // Guaranteed to succeed as this is CONST.
			// if value.Kind() != constant.Int {
			// 	log.Fatalf("can't happen: constant is not an integer %s", name)
			// }
			i64, isInt := constant.Int64Val(value)
			u64, _ := constant.Uint64Val(value)
			// if !isInt && !isUint {
			// 	log.Fatalf("internal error: value of %s is not an integer: %s", name, value.String())
			// }
			if !isInt {
				u64 = uint64(i64)
			}

			comment := strings.TrimSpace(vspec.Comment.Text())
			v := Value{
				Name:                 name.Name,
				TrimmedName:          strings.TrimPrefix(name.Name, f.trimPrefix),
				Value:                u64,
				Signed:               info&types.IsUnsigned == 0,
				Str:                  value.String(),
				Comment:              comment,
				CommentSpecifiedType: getCommentSpecifiedType(comment),
			}

			f.values = append(f.values, v)
		}
	}
	return false
}

func getCommentSpecifiedType(comment string) string {
	i := strings.Index(comment, ":")
	if i == -1 {
		return ""
	}
	part := strings.TrimSpace(comment[0:i])
	return part
}
